<!DOCTYPE html>
<html>
<body>
	<h1>My First Post</h1>
	<p> I did this with Github. </p>

	<h2> Day 1 of #66daysofdata  </h2>
	<p>
		I started with revising the basics of Python. There are some expressions which always create some confusion. Sharing some of them

		1) Do you know the difference between round(4.8) and int(4.8)?
		Try guessing before proceeding further.
		int(x) removes whatever is present after the decimal.

		Code Sample:
		>>> int(4.8)
		4
		>>> round(4.8)
		5
		>>> int(4.2)
		4
		>>> round(4.2)
		4

		2) What would be the output for the expression (True or False):
		0.2+0.2+0.2==0.6

		If your answer was False, you guessed it right.

		Explanation:
		If you run 0.2+0.2+0.2, following is the output
		>>> 0.2+0.2+0.2
		0.6000000000000001

		You would wonder why? This is because the data is stored as binary format(base 2) in the computer, thus there is never a perfect base 10 number stored.

		So what is the solution, try rounding up after the summation, this brings the value as close as position to base 10:
		>> round(0.2+0.2+0.2,2)==round(0.6,2)
		True

		Reference: https://lnkd.in/e5MdDza

		Amazing concept Ken Jee
	</p>


	<h2>Day 2 of #66daysofdata</h2>
	<p>
		

	 Learn Python with me or revise if you know it already :)

	 Mutable vs Immutable Objects
	 -------------------------------

	 Mutable objects can be modified after their creation, same is not true in case of Immutable objects. 

	 What does this mean ? 

	 This means that a part of the object can be modified or something can be added without actually changing the reference pointer for a mutable object.
	Immutable objects cannot be modified but the value for the same can be reassigned, this basically creates a new reference pointer abandoning the previous one.

	Example for Mutable Objects: List, dict,set
	Example for Immutable Obkect: String, int, float

	What does this imply?

	This means that for a list listA[1]=4 is valid
	however for a string somestr,

	somestr[1]='1' will cause an exception

	Comment and tell me, what do you think? Is there something which is important that I should also know about mutability
	</p>


	<h2>Day 3 of #66daysofdata</h2>
	<p>
		

	Zip in Python

	Sometime we get data for related fields like height and weight of a person in separate lists however there is a need to group them together.

	person = ["Tom", "George", "Harry"]
	weight = [10, 12, 14]
	height = [100, 103, 167]

	How do we aggregate them together

	Option 1: Use for loop and using the indexes put them together.

	Option 2 (zip) : Use the function zip, this can help to group the values together grouping on the basis of the individual sequence in the original lists

	>> zipped = zip(person,weight,height)

	One can make lists, dictionaries on top of it

	>> list(zipped)
	[('Tom', 10, 100), ('George', 12, 103), ('Harry', 14, 167)]

	https://lnkd.in/eJcVJ-A
	</p>


	<h2>Day 4 of #66daysofdata</h2>
	<p>
		

		List Comprehension in Python

		This provides a much compressed approach of creating a list using another iterable which can be another list on its own.

		Along with implementing the for loop it also gives the option to add if/ else statements in case of conditions to be checked for adding values.

		In case of list comprehension, array does not need to be declared beforehand

		new_list = [x*x if x%5==0 else x for x in old_list]

		https://lnkd.in/e4mBKWV

		#python
	</p>	

	<h2>Day 5 of #66daysofdata</h2>
	<p>


	Docstring conventions

	Documentation of the modules programmed is extremely essential, it not only makes the code easier to read but also makes it understandable.

	As per the Python documentation, "A docstring is a string literal that occurs as the first statement in a module, function, class, or method definition." .

	Comments and Docstring are similar due to the fact that both provides useful additional information about the code. However docstring is different from the comments given it consists of the first lines in the code which provides the details of the purpose and attributes of the definition.

	def method name():
	"""
	Docstring with details mentioned
	"""

	How do we access it? Through the special attribute __doc__ or the help function

	>> print(print.__doc__)
	>> help(print)

	This is an old but good page to refer : https://lnkd.in/eVpZNNm

	https://lnkd.in/eTU5hWH

	</p>

	<h2>Day 6 of #66daysofdata</h2>
	<p>

Function Annotation in Python

These are completely optional metadata added rather for usage by the developers than anything else. The interpreter does not understand these annotations and computes the operations

def somefunc(a:int, b:int) -> int

Official documentation: https://lnkd.in/eCDEfkQ

</p>

<h2>Day 8 of #66daysofdata</h2>
<p>
	

Generators in Python

Assume you have a lot of data and you want to play around with the data, creating new lists can be one option where an entirely new list is returned after the transformation, another less memory intensive option is a "Generator" where at any point of time only one record is output however the state is preserved.

Lists are iterable. We can traverse through the lists using for loop.
Generator is an iterator in which the data is accessed though the __next__ method. Every iterator is an iterable too thus for loop will also work.
https://www.geeksforgeeks.org/python-difference-iterable-iterator/

The difference between list and a generator would be that you can try to iterate through the list again and again, however you can iterate only once through the generator object after which it does not output any data and gives a "StopIteration" exception.

"yield" keyword in python is used to create generator object.

How do we implement Generators

Following is an example code:

def list_of_data_for_range():
    # Using List Comprehension
    range_list = [x + 1 for x in range(5)]
    return range_list


def generator_of_data_for_range():
    for i in range(5):
        yield i + 1


if __name__ == "__main__":
    print("/************** List ***********/")
    print(list_of_data_for_range())
    print("Run list again")
    print(list_of_data_for_range())

    print("/************* Generator ************/")
    generator_data = generator_of_data_for_range()
    print("Print what is received in generator")
    print(generator_data)
    # Using the next method
    print("Print first item of generator")
    print(next(generator_data))
    # Using for loop like any iterable
    print("Print remaining items of generator")
    for data in generator_data:
        print(data)

    print("Rerun iteration on generator")
    print(next(generator_data))


    Output:

	/************** List ***********/
	[1, 2, 3, 4, 5]
	Run list again
	[1, 2, 3, 4, 5]
	/************* Generator ************/
	Print what is received in generator
	<generator object generator_of_data_for_range at 0x100ee1f20>
	Print first item of generator
	1
	Print remaining items of generator
	2
	3
	4
	5
	Rerun iteration on generator
	Traceback (most recent call last):
	  File "generator.py", line 31, in <module>
	    print(next(generator_data))
	StopIteration

	Process finished with exit code 1



More context: https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do 
</p>
</body>

</html>